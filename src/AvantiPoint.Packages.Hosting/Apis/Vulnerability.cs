using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using AvantiPoint.Packages.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;

namespace AvantiPoint.Packages.Hosting;

#nullable enable
internal static class Vulnerability
{
    public static WebApplication MapVulnerabilityApi(this WebApplication app)
    {
        var options = app.Services.GetRequiredService<IOptions<PackageFeedOptions>>().Value;

        // Only map vulnerability endpoints if the feature is enabled
        if (options.EnableVulnerabilityInfo)
        {
            app.MapGet("v3/vulnerabilities/index.json", GetVulnerabilityIndex)
               .AllowAnonymous()
               .WithTags(nameof(Vulnerability))
               .WithName(Routes.VulnerabilityIndexRouteName);
        }

        return app;
    }

    [ProducesResponseType(typeof(VulnerabilityIndexResponse), 200, "application/json")]
    private static async Task<IResult> GetVulnerabilityIndex(
        IVulnerabilityService vulnerabilityService,
        CancellationToken cancellationToken)
    {
        // Get the latest update timestamp
        var latestUpdate = await vulnerabilityService.GetLatestUpdateTimestampAsync(cancellationToken);

        // For now, we'll use a single page containing all vulnerabilities
        // In a production system, this could be split into multiple pages
        var pages = new List<VulnerabilityPageInfo>();

        if (latestUpdate.HasValue)
        {
            pages.Add(new VulnerabilityPageInfo
            {
                Id = "vulnerabilities-base.json",
                Name = "base",
                Updated = latestUpdate.Value
            });
        }

        var response = new VulnerabilityIndexResponse
        {
            Version = "6.7.0",
            Pages = pages
        };

        return Results.Ok(response);
    }
}

/// <summary>
/// Represents the vulnerability index response.
/// </summary>
public class VulnerabilityIndexResponse
{
    /// <summary>
    /// The version of the vulnerability index format.
    /// </summary>
    [JsonPropertyName("version")]
    public string Version { get; set; } = string.Empty;

    /// <summary>
    /// The list of vulnerability pages.
    /// </summary>
    [JsonPropertyName("pages")]
    public List<VulnerabilityPageInfo> Pages { get; set; } = new();
}

/// <summary>
/// Represents a vulnerability page entry in the index.
/// </summary>
public class VulnerabilityPageInfo
{
    /// <summary>
    /// The URL or identifier for this page.
    /// </summary>
    [JsonPropertyName("@id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The name of this page.
    /// </summary>
    [JsonPropertyName("@name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// The timestamp when this page was last updated.
    /// </summary>
    [JsonPropertyName("@updated")]
    public DateTime Updated { get; set; }
}
