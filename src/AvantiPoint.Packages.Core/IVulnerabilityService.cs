using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;

namespace AvantiPoint.Packages.Core
{
    /// <summary>
    /// Service for accessing vulnerability data.
    /// </summary>
    public interface IVulnerabilityService
    {
        /// <summary>
        /// Get all vulnerabilities for a specific package ID.
        /// </summary>
        /// <param name="packageId">The package ID (case-insensitive)</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>List of vulnerabilities affecting the package</returns>
        Task<IReadOnlyList<PackageVulnerability>> GetPackageVulnerabilitiesAsync(
            string packageId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the most recent update timestamp across all vulnerabilities.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>The most recent update timestamp, or null if no vulnerabilities exist</returns>
        Task<DateTime?> GetLatestUpdateTimestampAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all package IDs that have associated vulnerabilities.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>List of package IDs with vulnerabilities</returns>
        Task<IReadOnlyList<string>> GetPackageIdsWithVulnerabilitiesAsync(
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Default implementation of vulnerability service.
    /// </summary>
    public class VulnerabilityService : IVulnerabilityService
    {
        private readonly IContext _context;

        public VulnerabilityService(IContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        public async Task<IReadOnlyList<PackageVulnerability>> GetPackageVulnerabilitiesAsync(
            string packageId,
            CancellationToken cancellationToken = default)
        {
            var normalizedPackageId = packageId.ToLowerInvariant();

            var vulnerabilities = await _context.PackageVulnerabilities
                .AsNoTracking()
                .Include(pv => pv.Vulnerability)
                .Where(pv => pv.PackageId == normalizedPackageId)
                .OrderBy(pv => pv.VersionRange)
                .ThenBy(pv => pv.Vulnerability.AdvisoryUrl)
                .ToListAsync(cancellationToken);

            return vulnerabilities.AsReadOnly();
        }

        public async Task<DateTime?> GetLatestUpdateTimestampAsync(CancellationToken cancellationToken = default)
        {
            return await _context.VulnerabilityRecords
                .AsNoTracking()
                .MaxAsync(v => (DateTime?)v.UpdatedUtc, cancellationToken);
        }

        public async Task<IReadOnlyList<string>> GetPackageIdsWithVulnerabilitiesAsync(
            CancellationToken cancellationToken = default)
        {
            var packageIds = await _context.PackageVulnerabilities
                .AsNoTracking()
                .Select(pv => pv.PackageId)
                .Distinct()
                .OrderBy(id => id)
                .ToListAsync(cancellationToken);

            return packageIds.AsReadOnly();
        }
    }
}
